<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Growth Complexity of Algorithms Demo</title>

    <link href="../static/css/bootstrap.min.css" media="all" rel="stylesheet"  type="text/css">
    <link href="../static/css/main.css" media="all" rel="stylesheet" type="text/css">
    <link href="../static/css/nouislider.min.css" rel="stylesheet" />
    <link href="../static/css/brand.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400" rel="stylesheet">
    <script src="https://use.fontawesome.com/84b0cfaa21.js"></script>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  </head>

  <body class="site solarized_base1">
    <div class="ppi"></div>
    <nav class="navbar navbar-default navbar-fixed-top">
      <div class="container-fluid">
        <div class="navbar-header">
          <a type="a" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapse-elements">
            <span class="sr-only">Toggle Navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="navbar-brand" id="push-brand" href="/">
            <i class="fa fa-code" aria-hidden="true"></i>
            <!-- <i class="icon-sort-icon"></i> -->
            <!-- <i class="icon-tree-algorithm"></i> -->
          </a>
        </div>

        <div class="navbar-collapse collapse" id="collapse-elements">
          <ul class="nav navbar-nav">
            <li>
              <!-- <a href="resources"> -->
                <a href="{{ url_for('static', filename='html/resources.html') }}">
                <span class="btn-addon">[</span>
                  Resources
                <span class="btn-addon">]</span>
              </a>
            </li>
            <li>
              <!-- <a href="overview"> -->
                <a href="{{ url_for('static', filename='html/overview.html') }}">
                <span class="btn-addon">[</span>
                  Overview
                <span class="btn-addon">]</span>
              </a>
            </li>
            <!-- <li><a href="#">three</a></li> -->
          </ul>
        </div>
      </div>
    </nav>

    <main class="content-wrapper">
      <div class="container-fluid">
        <div class="row">

          <div class="col-sm-6 outer-col">
            <!-- <br/> -->
            <div class="pad">
              <div class="title">// Algorithms, Time Complexity and Big O Notation</div>
              <div class="text"> <!-- id="show-text"> -->
                <!-- <br/> -->
                <p>
                Hello and welcome! This site is my first web development project and it functions as a kind of learning platform. After some uncertainty about how to make a start at actually <em class="solarized_base1_lightened">building</em> something, I decided to just let my interest guide me. For me this meant I wanted to review the fundamentals of algorithm <em class="solarized_base1_lightened">time complexity</em>. Since this subject matter lends itself to visualization (by plotting rates of change on a graph), I decided to attempt to present a few interactive plots, with accompanying brief discussion of what I'm learning about algorithms. As such, the effort to articulate these concepts clearly is an ongoing project in itself. I'm eager to build my understanding so feedback is welcome (contact info is in the footer).
                </p>
                <!-- <br/> -->
                <p>
                You can read a detailed <a href="{{ url_for('static', filename='html/overview.html') }}">overview</a> of my motivation and progress in building this site. I'm also compiling a list of helpful <a href="{{ url_for('static', filename='html/resources.html') }}">resources</a> for beginner / further study. You'll find the GitHub repository <a href="https://github.com/jaf7/mpld3-growth-complexity-demo">here</a> (the README contains additional info and my current TODO / FIXME list). This site's styling is inspired by the strikingly cool <a class="musicforprogramming" href="https://musicforprogramming.net/">Music For Programming</a> site by <a class="musicforprogramming" href="http://johndatadavies.info/">John Davies</a>. This is an ongoing learning experience, and it's perhaps as valuable for uncovering how <em class="solarized_base1_lightened">not</em> to do some things as for learning appropriate practices. I currently think that on balance, as a beginner, it's good to have a project where you can play around and throw things at the wall. It provides numerous opportunities for mistakes, backtracking, changing, and refining as you learn. And it's serious fun!
                </p>
                <!-- <br/> -->

                <hr class="style_1">
                <!-- <br/> -->

                <div class="subhead">// What is an Algorithm?</div>
                <p>
                There's an interesting fact about problem solving: we tend not to solve the same problem over and over again. That is, we don't reformulate a solution to a problem every time we're confronted with it. A problem solution by its nature is something we can re-use. Of course we often refine solutions, or alter them to fit a particular case just so. But the structure--the pattern of a formulated solution--tends to remain stable in a significant way. Otherwise I'd offer that it's a different, alternative solution. And indeed, discerning the most appropriate solution to apply, out of the alternatives we can formulate, is a crucial skill in problem solving. With long and intentional practice, we can become amazingly adept at this skill of discerning application.
                </p>
                <!-- <br/> -->
                <p>
                An algorithm is an explicit way of expressing a solution by recasting it into a series of ordered, unambiguous steps that, given an input, produce a result. In a general sense, a <a href="https://iambaker.net/the-perfect-chocolate-cake/">recipe</a> for chocolate cake, or <a href="https://goo.gl/maps/EENUAFtoGqJ2">directions</a> to a museum in the city, or the <a href="http://www.thisoldtractor.com/projects_roy_smith_2013-03-19_inspect_and_prepare_the_crankcase.html">steps</a> to rebuild a motorcycle engine are all algorithms. And so are the steps in code that effect the ordering of a list, and the steps in code that effect a search for an item in that list.
                </p>

                <p>
                Problems we encounter as developers can be highly complex. When we think of complexity, we intuitively relate this to the difficulty in solving a problem. Baking a cake might be less difficult, less complex, than rebuilding a motorcycle engine (perhaps depending on who's doing the work). In the face of complexity we're obliged to decompose problems into simpler sub-problems. As we do the work of decomposition, we can reach a point where we've articulated discrete units of work, (operations or steps) to be performed. In computation, when these steps lead from an input to a solution output, we've formulated an algorithm. And we are able to generalize this series of steps to apply to many variations of the original problem. But there are almost always multiple approaches to solving a problem. How do we decide what the most effective way is, given our constraints? For the sake of simplicity and to facilitate grasping the fundamental concepts, here we'll consider just one constraint: execution time or <em class="solarized_base1_lightened">running time</em>, which in computer science is referred to as <em class="solarized_base1_lightened">time complexity</em>.
                </p>
                <!-- <br/> -->

                <hr class="style_1">
                <!-- <br/> -->

                <div class="subhead">// What is Time Complexity?</div>
                <p>
                Time complexity refers to how the running time of an algorithm grows as its input scales. It's a tool for analyzing how efficiently one class of algorithms will compute a solution, relative to other kinds of algorithms, and independent of their operating environment (how fast the processor is, or how the programming language is implemented, for example). This independence results in part from the fact that when analyzing time complexity, we consider not elapsed clock time, but instead the <em class="solarized_base1_lightened">number of operations performed</em> to reach a solution.<a class="footnote" id="footnote-1-ref" href="#footnote-1" aria-label="See footnote">[1]</a> (We'll examine another kind of "independence" momentarily). When we ask what the time complexity of an algorithm is, we are asking (in part) about the <em class="solarized_base1_lightened">rate of growth</em> of this number, as our input size increases. That is, how quickly does the number of operations performed increase as the size of the input increases? This rate of growth gives us something concrete to compare to other algorithm growth rates. And we do this comparison to understand the relative resource consumption of different kinds of algorithmic solutions. We are asking "what is the computational cost of this solution?" and we're producing a concrete, quantified answer.
                </p>
                <p class="footnote-ref" id="footnote-1">[1] In order to best lay a foundational understanding, we hold the time value of an "operation" constant here. That is, we assume that the amount of time it takes to perform any discrete operation is identical. <a href="#footnote-1-ref" aria-label="Return to text">&#8617;</a></p>
                <!-- <br/> -->

                <hr class="style_1">
                <!-- <br/> -->

                <div class="subhead">// What is Big O Notation?</div>
                <p class="waypoint" id="what-is-big-o">
                To return briefly to the notion of <em class="solarized_base1_lightened">independence</em>: while a certain kind of independence (from a particular operating environment) can be achieved by considering the number of operations performed by the algorithm (instead of elapsed compute time), what about the <em class="solarized_base1_lightened">input value</em> itself? Doesn't the efficiency of an algorithm still depend on the particular input value(s) provided? Let's illustrate this. Let's say we have an array (or list) of unique non-repeating values that we want to search for a particular element. We'll search this array with an algorithm (the function <span class="microlight">iterateArray</span>) by iterating over it, checking for equivalence, and returning true if the value is present in the array or false otherwise:
                </p>
                <div class="row">
                  <div class="col-xs-10 col-xs-offset-1">
                    <div class="microlight" contenteditable="true">function iterateArray( inputArray, element ) {
  for ( let i = 0; i < inputArray.length; i++ ) {
    if ( inputArray[i] === element ) {
      return true;
    }
  }
  return false;
}
                    </div>
                  </div>
                </div>
                <p>
                Now let's say that our input array is a sorted list of integers from 1 to 100: <span class="microlight">[1,2,3,4,5,6, ...100]</span>. How many operations will it take to return a match? The answer is <em class="solarized_base1_lightened">dependent</em> on the size of our input array, and the element we're searching for: if we make <span class="microlight">element = 5</span>, iterateArray() will perform 5 comparisons (while evaluating the <span class="microlight">if</span> statement) to match the integer 5. But if <span class="microlight">element = 50</span>, the number of comparison operations increases by 45. As our list size grows, the potential cost in operations required to match an element in it grows. If our array contains <span class="microlight">1,000,000</span> elements, this algorithm will match <span class="microlight">element = 5</span> in many fewer operations than it will take to match the element at index 999,999. It seems that the speed of this algorithm can vary a great deal. So how do we establish a reliable representation of this algorithm's efficiency, so that we can compare it to other algorithms?
                </p>
                <p>
                It seems we need to somehow <em class="solarized_base1_lightened">abstract</em> away from this variability if we are to treat this algorithm as part of a general class, to which we can compare other classes of algorithms. It turns out that we can perform this abstraction by considering such algorithms strictly in a <em class="solarized_base1_lightened">worst case</em> scenario. This worst case is also referred to as an <em class="solarized_base1_lightened">upper bound</em>: meaning we can impose a constraint on our input value(s), one that always represents these values as the <em class="solarized_base1_lightened">most costly</em> to obtain an output solution from. For every algorithm pattern we analyze, we assume this worst case. In this way, the effect of the variability we observed above becomes insignificant (its impact on algorithm performance becomes vanishingly small). We are examining the performance of our algorithm as we approach an upper bound in computation cost (such as an arbitrarily large input array size). In turn, we can impose the same constraint on a different algorithm, and in this way we can make a comparison that is independent of particular input configurations.
                </p>
                <p>
                With this approach we can make two useful examinations: first, how an algorithm type's efficiency changes as its input size grows, and second, how the efficiency of one algorithm type compares to the efficiency of another algorithm type. Take our example code above. In the first examination, we might observe what happens as the size of our input array grows arbitrarily large. At what rate will our number of operations grow? In the latter examination, we can compare the relative growth rates of two different types of algorithm (such as the one we've expressed above compared to a second, different pattern). But how do we describe these <em class="solarized_base1_lightened">growth rates</em>? We express them as discrete <em class="solarized_base1_lightened">Orders of Growth</em>: with <em class="solarized_base1_lightened">big</em> "O" notation (literally using a capital "O").
                </p>
                <!--
                Define Running Time: # operations performed
                Define Growth Rate: How quickly does this *operations performed* value increase as input size increases?

                In this demonstration I'm attempting to visualize and gain some preliminary, intuitive understanding of the relative efficiency of some common types of algorithms, given an identical environment with regard to memory and operations performed per unit of time. Thus the intent of these visualizations is to perceive the relative growth rates that these algorithms yield in terms of number of operations performed.

                (And although it will be crucial to understand the suitability of a given algorithm pattern for processing different data structures, the appropriate first step is to artificially limit my scope to growth rates, and afterwards study their applications)

                The rate of growth of running times:
                The running times of different algorithms don't grow at the same rate. As the input size increases, what matters is the relative rate of growth in running time. In Big O notation, we abstract away from units of time elapsed in any particular instance.
                We also limit consideration to how input size is related to number of operations performed.
                In addition, it makes sense at the start to limit scope to *worst case* scenarios only. This way a parameter is established: a given operation will never run more slowly than it's analyzed Big O run time. This parameter is a base from which to define and understand how to implement "best case" or "average case" operations.
                 -->
                <hr class="style_1">

                <p>
                Take a moment to read the info in the Growth Plot area to the right (below on mobile).
                </p>

                <hr class="style_1">

                <div class="subhead">// Linear Growth
                  <button class="linearLog btn btn-plot-choice">
                    <span class="btn-addon">[</span>
                    `O(n),O(log n)`
                    <span class="btn-addon">]</span>
                  </button>
                </div>
                <p class="waypoint growthDescription" id="linearLog">
                <!-- In simple search, the max number of operations = size of input. -->
                Let's begin to illustrate this using our first algorithm from above, <span class="microlight">iterateArray</span>. This algorithm is an example of <em class="solarized_base1_lightened">linear search</em>. It's growth rate is <em class="solarized_base1_lightened">linear</em>. That is, <em class="solarized_base1_lightened">in the worst case</em>, the number of operations it must perform to return a solution grows at a rate directly proportional to the size of the input data (an array in our case). Take a look at the plotted linear growth rate for such an algorithm (for the moment, ignore the orange "log" plot).
                </p>
                <div class="row">
                  <div class="col-xs-10 col-xs-offset-1">
                    <div class="microlight" contenteditable="true">function iterateArray( inputArray, element ) {
  for ( let i = 0; i < inputArray.length; i++ ) {
    if ( inputArray[i] === element ) {
      return true;
    }
  }
  return false;
}
                    </div>
                  </div>
                </div>
                <p>
                [BEGIN LOREM IPSUM] Ethical Kickstarter PBR asymmetrical lo-fi. Dreamcatcher street art Carles, stumptown gluten-free Kickstarter artisan Wes Anderson wolf pug. Godard sustainable you probably haven't heard of them.
                </p>
                <p>
                Vegan farm-to-table Williamsburg slow-carb readymade disrupt deep v. Meggings seitan Wes Anderson semiotics, cliche American Apparel whatever. Helvetica cray plaid, vegan brunch Banksy leggings +1 direct trade. Wayfarers codeply PBR selfies. Banh mi McSweeney's Shoreditch selfies, forage fingerstache food truck occupy YOLO Pitchfork fixie iPhone fanny pack art party Portland.
                </p>

                <div class="subhead">// Logarithmic Growth
                  <button class="linearLog btn btn-plot-choice">
                    <span class="btn-addon">[</span>
                    `O(n),O(log n)`
                    <span class="btn-addon">]</span>
                  </button>
                </div>
                <p>
                <!-- "log time" is what the natives call it -->
                <!-- https://www.khanacademy.org/math/algebra2/exponential-and-logarithmic-functions/introduction-to-logarithms/v/logarithms -->
                <!-- code: binary_search.py, binary_search.rb -->
                <!-- Binary search requires log n operations to search a list of size n. -->
                Ethical Kickstarter PBR asymmetrical lo-fi. Dreamcatcher street art Carles, stumptown gluten-free Kickstarter artisan Wes Anderson wolf pug. Godard sustainable you probably haven't heard of them, vegan farm-to-table Williamsburg slow-carb readymade disrupt deep v. Meggings seitan Wes Anderson semiotics, cliche American Apparel whatever. Helvetica cray plaid, vegan brunch Banksy leggings +1 direct trade. Wayfarers codeply PBR selfies. Banh mi McSweeney's Shoreditch selfies, forage fingerstache food truck occupy YOLO Pitchfork fixie iPhone fanny pack art party Portland.
                </p>
                <div class="subhead">// Log-Linear Growth
                  <button class="linearLogLinear btn btn-plot-choice">
                    <span class="btn-addon">[</span>
                    `O(n),O(nlogn)`
                    <span class="btn-addon">]</span>
                  </button>
                </div>
                <p class=" waypoint growthDescription" id="linearLogLinear">
                Sriracha biodiesel taxidermy organic post-ironic, Intelligentsia salvia mustache 90's code editing brunch. Butcher polaroid VHS art party, hashtag Brooklyn deep v PBR narwhal sustainable mixtape swag wolf squid tote bag. Tote bag cronut semiotics, raw denim deep v taxidermy messenger bag. Tofu YOLO Etsy, direct trade ethical Odd Future jean shorts paleo. Forage Shoreditch tousled aesthetic irony, street art organic Bushwick artisan cliche semiotics ugh synth chillwave meditation. Shabby chic lomo plaid vinyl chambray Vice. Vice sustainable cardigan, Williamsburg master cleanse hella DIY 90's blog.
                </p>
                <div class="subhead">// Quadratic Growth
                  <button class="logLinearQuadratic btn btn-plot-choice">
                    <span class="btn-addon">[</span>
                    `O(nlogn),O(n^2)`
                    <span class="btn-addon">]</span>
                  </button>
                </div>
                <p class="waypoint growthDescription" id="logLinearQuadratic">
                Sriracha biodiesel taxidermy organic post-ironic, Intelligentsia salvia mustache 90's code editing brunch. Butcher polaroid VHS art party, hashtag Brooklyn deep v PBR narwhal sustainable mixtape swag wolf squid tote bag. Tote bag cronut semiotics, raw denim deep v taxidermy messenger bag. Tofu YOLO Etsy, direct trade ethical Odd Future jean shorts paleo. Forage Shoreditch tousled aesthetic irony, street art organic Bushwick artisan cliche semiotics ugh synth chillwave meditation. Shabby chic lomo plaid vinyl chambray Vice. Vice sustainable cardigan, Williamsburg master cleanse hella DIY 90's blog.
                </p>
                <div class="subhead">// Exponential Growth
                  <button class="quadraticExponential btn btn-plot-choice">
                    <span class="btn-addon">[</span>
                    `O(n^2),O(2^n)`
                    <span class="btn-addon">]</span>
                  </button>
                </div>
                <p class="waypoint growthDescription" id="quadraticExponential">
                Sriracha biodiesel taxidermy organic post-ironic, Intelligentsia salvia mustache 90's code editing brunch. Butcher polaroid VHS art party, hashtag Brooklyn deep v PBR narwhal sustainable mixtape swag wolf squid tote bag. Tote bag cronut semiotics, raw denim deep v taxidermy messenger bag. Tofu YOLO Etsy, direct trade ethical Odd Future jean shorts paleo. Forage Shoreditch tousled aesthetic irony, street art organic Bushwick artisan cliche semiotics ugh synth chillwave meditation. Shabby chic lomo plaid vinyl chambray Vice. Vice sustainable cardigan, Williamsburg master cleanse hella DIY 90's blog.
                </p>
                <!-- <br/> -->

                <hr class="style_1">
                <!-- <br/> -->

                <div class="subhead">// Further Reading</div>
                <p>
                Sriracha biodiesel taxidermy organic post-ironic, Intelligentsia salvia mustache 90's code editing brunch. Butcher polaroid VHS art party, hashtag Brooklyn deep v PBR narwhal sustainable mixtape swag wolf squid tote bag. Tote bag cronut semiotics, raw denim deep v taxidermy messenger bag. Tofu YOLO Etsy, direct trade ethical Odd Future jean shorts paleo. Forage Shoreditch tousled aesthetic irony, street art organic Bushwick artisan cliche semiotics ugh synth chillwave meditation. Shabby chic lomo plaid vinyl chambray Vice. Vice sustainable cardigan, Williamsburg master cleanse hella DIY 90's blog.
                </p>
              </div> <!-- #show-text -->
            </div>
          </div> <!-- col-sm-6 (left column) -->

          <div class="col-sm-6 outer-col" data-spy="affix">
              <!-- <br/> -->
              <!-- <h4>// Input Range</h4> -->
              <div class="subhead">// Input Range</div>
              <!-- <br/> -->
              <div class="slider-wrapper">
                <div class="noUi-extended" id="limit-slider"></div>
                <!-- input fields -->
                <div class="input-wrapper">
                  <div class="input-group pull-left">
                    <span class="input-group-addon" id="basic-addon1">[</span>
                    <input value="1" id="lower-limit-input" class="limit-input"/>
                    <span class="input-group-addon" id="basic-addon2">]</span>
                  </div>
                  <div class="input-group pull-right">
                    <span class="input-group-addon" id="basic-addon3">[</span>
                    <input value="1000" id="upper-limit-input" class="limit-input"/>
                    <span class="input-group-addon"  id="basic-addon4">]</span>
                  </div>
                </div>
              </div> <!-- slider-wrapper -->
              <br />

              <!-- <h4>// Growth Plot</h4> -->
              <div class="subhead" id="growth-plot">// Growth Plot</div>
              <div id="plot-space">
              <!-- <br/> -->
                <div class="solarized_blue" id="plot-info">
                   Scroll down to view plotted comparisons of algorithm run times.
                   <!-- <br/> -->
                   On mobile, click the plot-type button labeled with the corresponding Big O notation.
                   <!-- <br/> -->
                   Try changing the input size above with the sliders, or by entering new numbers.
                   <hr class="style_2">
                   When you hover / touch the graph, these icons
                   <img src="../static/images/mpld3-icons.png" alt="graph icons: home, move, magnify">
                   appear at the graph's bottom left. Click on them to reset
                   <img src="../static/images/home.png" alt="home icon">
                   move <img src="../static/images/move.png" alt="move icon">
                   and magnify <img src="../static/images/magnify.png" alt="magnify icon">
                   the graph.
                </div>
              </div> <!-- start with empty node -->

          </div> <!-- col-sm-6 (right column) -->
        </div> <!-- row -->
      </div> <!-- container-fluid -->
    </main>

    <footer>
      <div class="container">
        <div class="row">
          <div class="col-xs-9">
            <div class="footer-inner-left">
              <h5 class="footer-text">
                // Caffeinated Electrons &copy; 2017 //
                <i>Made with
                  <span class="fa fa-coffee"></span>&nbsp;
                  <span class="fa fa-headphones"></span> and&nbsp;
                  <span class="fa fa-heart"></span>
                </i>
                // Contact:
                <span class="glyphicon glyphicon-globe"></span> Santa Fe, NM
                <span class="glyphicon glyphicon-phone"></span> 1-555-electrons
                <span class="glyphicon glyphicon-envelope"></span>
                <a href="mailto:#">janthonyfields@gmail.com</a>
              </h5>
            </div>
          </div>
          <div class="col-xs-3">
            <div class="footer-inner-right">
              <div class="footer-img">
                <p>
                  <a href="https://twitter.com/janthonyfields"><i class="fa fa-twitter fa-2x"></i></a>
                  <!-- <a><i class="fa fa-linkedin fa-2x"></i></a> -->
                  <a href="https://github.com/jaf7/mpld3-growth-complexity-demo"><i class="fa fa-github fa-2x"></i></a>
                  <!-- <a><i class="fa fa-codepen fa-2x"></i></a> -->
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </footer>

    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=AM_HTMLorMML">
    </script>
    <script type="text/javascript" src="../static/js/jquery-3.1.1.min.js"></script>
    <script type="text/javascript" src="../static/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../static/js/bootstrap-toolkit.min.js"></script>
    <script type="text/javascript" src="../static/js/nouislider.min.js"></script>
    <script type="text/javascript" src="../static/js/wNumb.js"></script>
    <script type="text/javascript" src="../static/js/classList.js"></script> <!-- https://github.com/eligrey/classList.js -->
    <script type="text/javascript" src="../static/js/jquery.waypoints.min.js"></script>
    <script type="text/javascript" src="../static/js/microlight.js"></script>
    <script type="text/javascript" src="../static/js/app.js"></script>

  </body>
</html>
